{"ast":null,"code":"import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach(({\n        name\n      }, index) => {\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n        }\n      }\n\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        error\n      }));\n      break;\n    }\n  }\n\n  return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext); // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: options.outputChannelCount[i]\n          }));\n        }\n\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          } // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n\n\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n\n        return outputGainNode;\n      }\n\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n      return nativeAudioWorkletNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","map":{"version":3,"sources":["/Users/michael/Documents/GitHub/composer/composer/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js"],"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","outputChannelCount","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","trace","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","Promise","all","values","audioParam","constantSourceNode","offset","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","loop","loopEnd","loopStart","playbackRate","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"mappings":"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","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-worklet-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}