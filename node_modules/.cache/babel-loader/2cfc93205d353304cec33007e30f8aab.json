{"ast":null,"code":"import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n  return (nativeContext, {\n    offset,\n    ...audioNodeOptions\n  }) => {\n    const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n    const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      playbackRate: 1\n    });\n    const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: offset\n    }); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n\n    const channelData = audioBuffer.getChannelData(0); // Bug #95: Safari does not play or loop one sample buffers.\n\n    channelData[0] = 1;\n    channelData[1] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.loop = true;\n    const nativeConstantSourceNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        gainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        gainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return gainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        gainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return gainNode.context;\n      },\n\n      get inputs() {\n        return [];\n      },\n\n      get numberOfInputs() {\n        return audioBufferSourceNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return gainNode.numberOfOutputs;\n      },\n\n      get offset() {\n        return gainNode.gain;\n      },\n\n      get onended() {\n        return audioBufferSourceNode.onended;\n      },\n\n      set onended(value) {\n        audioBufferSourceNode.onended = value;\n      },\n\n      addEventListener(...args) {\n        return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return audioBufferSourceNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n      },\n\n      start(when = 0) {\n        audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n      },\n\n      stop(when = 0) {\n        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n      }\n\n    };\n\n    const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode); // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, audioBufferSourceNode);\n    return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["/Users/michael/Documents/GitHub/composer/composer/node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js"],"names":["interceptConnections","createNativeConstantSourceNodeFakerFactory","addSilentConnection","createNativeAudioBufferSourceNode","createNativeGainNode","monitorConnections","nativeContext","offset","audioNodeOptions","audioBuffer","createBuffer","sampleRate","audioBufferSourceNode","buffer","channelCount","channelCountMode","channelInterpretation","loop","loopEnd","loopStart","playbackRate","gainNode","gain","channelData","getChannelData","nativeConstantSourceNodeFaker","bufferSize","undefined","value","context","inputs","numberOfInputs","numberOfOutputs","onended","addEventListener","args","dispatchEvent","removeEventListener","start","when","call","stop","whenConnected","connect","whenDisconnected","disconnect"],"mappings":"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","sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-constant-source-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}